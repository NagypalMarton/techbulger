console.log("Hello, This is the console Message!");
let price1=5; /* definició*/
console.log(price1);
let price2=10;
console.log(price2);
let total=price1+price2;
console.log(total);
let name;/* deklalálás;= => érték adó operátor*/

const szo='Étlap'; /* Állandó, nem lehet megváltoztatni az értékét és cak ilyenkor lehet értéket adni*/
console.log(szo);/*camelCase => Szavak kezdetét nagy betűkkel */

/*változók*/
Boolean
Number
String
null
undefined
typeof Number
typeof szo
let bool=true
typeof bool
/*tulajdonságok, metódusok lekérdezése */
price2.toString()
szo.length
szo.replace("a","b")

/*számok*/
let userAge=33;
userAge=userAge-5;
userAge=userAge/2;
console.log(userAge);
/*mARADÉKOT ad vissza */
console.log(6%3)
console.log(6%5)
/*precedencia szabály*/
console.log(((2+3*2/(5+8))%5)**6)

/*String */
let UserName="Kiss Péter"
let userName='Nagy József'
console.log(UserName)
console.log(typeof UserName)
console.log(UserName.length)
console.log(typeof userName)
let UM=userName + " " + UserName
console.log(UM)

/*Létezik? */
let carName
console.log(typeof carName)
carName="fIAT tIPE"
console.log(typeof carName)
carName=null /*Kiürítettem */
console.log(typeof carName)

/*Átalakítások */
let door='11'
/*implicit */
console.log(door)
console.log(door*2)
console.log(door-2)
console.log(door/2)
console.log(door+2)/*Ilyenkor a string az erőssebb */
/*Kénysszerítés Explicit*/
console.log(String(door)+2)
console.log(Number(door)+2)
let dooor='Hello'
console.log(Number(dooor))
userAge=33
console.log(String(33))
console.log(typeof userAge.toString()) /*ez gyorsabb */
let amount = 653.2134234
/*Kerekíti */
console.log(amount.toFixed(2))
console.log(amount.toPrecision(7))/*Összes számjegyre érvényes */
console.log(parseInt("22"))
console.log(parseInt("22Hall"))
console.log(parseInt("Hall33"))
console.log(parseInt("22Hall34"))
console.log(parseFloat("22.65"))
console.log(parseFloat("f22.65"))

/*Metódus*/
Mit tud csinálni egy típus
length => str hossza
trim() Eltávolítja a felesleges szóközöket, amelyek a String előtt és után találhatóak.
﻿concat()\tt concat()concat()﻿
Új karaktereket fűz hozzá a meglévő Stringhez.
﻿toLowerCase()\tt toLowerCase()toLowerCase()﻿
Kisbetűssé alakítja az adott Stringet.
﻿toUpperCase()\tt toUpperCase()toUpperCase()﻿
Az előzővel ellentétben nagybetűssé alakítja a karaktereket.

/*Keresés és módosítás egy Stringen belül*/
indexOf()﻿
Megkeresi a Stringen belül egy adott szövegrész kezdetét.
A kezdő karakter indexét adja vissza, amely 0-tól kezdődik, azaz az első karakter a 0 sorszámú és így tovább.

replace()﻿
Kicseréli a megadott szövegrészt a Stringen belül. Ahogy a példában is látni fogod, ennek a metódusnak kettő darab úgynevezett paramétere van, tehát két adatot kell a zárójelek között megadni:

    először azt, amit cserélni szeretnél,
    azután pedig azt, amire ki szeretnéd cserélni.

/*Boolean => IGAZ/HAMIS*/
    0 => HAMIS
    1 => IGAZ
Logikai kifejezés => Olyan kifejezés, amely kiértékelése után ﻿true\tt truetrue﻿ vagy ﻿false\tt falsefalse﻿ értéket ad vissza.
operátorok: >, <, >=, <=, 
    == megegyező érték, === megegyező érték és típus,
    != nem megegyező érték,
!== nem megegyező érték és típus,
! tagadás - logikai érték megfordítása,
&& és,
|| vagy
10 + "text"     // "10text" - a számot szövegként kezelte  
10 + "10"       // "1010" - a számot szövegként kezelte most is, azonban:  
10 - "1"        // 9, tehát kivonás esetében számként kezelte  
10 + true       // 11, a true-t 1-nek veszi  
10 - true       // 9  
10 + false      // 10, a false-t 0-nak tekinti  
"10" + true     // "10true", a boolean értéket string-nek veszis

/*var test = [[1, 'szoveg'][true, false]]

 Primitív változó típusok: ﻿Boolean, Number,  \tt Boolean,\,Number,\,Boolean,Number,﻿﻿String, Undefined, Null\tt String,\,Undefined,\,NullString,Undefined,Null*/
/*slice(start,end) ha minusz, akkor a végén kezdi a vágást
splice(index,howmany,item1,item2) eredetit módosítja és hozzáadja
join() => tömb elemeiből stringet csinál

alert("A week_temp Tömb-e? " + Array.isArray(week_temp))
    week_temp.push("54")/*Érték hozzáadása a végére*/
   /* alert("A tömb értékei: " + week_temp)
    week_temp.pop("54")/*Elem elvétele a végéről*/
   /* week_temp.unshift("43")/*Elem hozzadása az elejéhez */
   /* week_temp.shift(4)/*elem elvétele bárhonnan*/
   /* alert("A tömb 0. értékei: " + week_temp[0] + ' ' + test[0][1])
*/

Ciklusok
========
for
for (var i=0; i<5;i++){
    console.log(i)
}

tomb bejarasa
for (var i=0; i<arr.length;i++){
    console.log(i)
}
continue => ha valamiért úgy döntesz, hogy mégsem akarod lefuttatni a teljes ciklusmagot
break => megszakítja a ciklust, azaz a ciklusmag többet nem kerül végrehajtásra, úgy is mondhatnánk, a program továbbmegy.

Compound operators
Hozzáadás: ﻿x = x + 10 \texttt {x = x + 10} x = x + 10﻿ helyett ﻿x += 10 \texttt {x += 10} x += 10﻿
Kivonás: ﻿x = x - 10 \texttt {x = x - 10} x = x - 10﻿ helyett ﻿x -= 10 \texttt {x -= 10} x -= 10﻿
Osztás: ﻿x = x / 2 \texttt {x = x / 2} x = x / 2﻿ helyett ﻿x /= 2 \texttt {x /= 2} x /= 2﻿
Modulus (maradék): ﻿x = x % 2 \texttt {x = x \% 2} x = x % 2﻿ helyett ﻿x %= 2 \texttt {x \%= 2} x %= 2﻿
Szorzás: ﻿x = x * 10 \texttt {x = x * 10} x = x * 10﻿ helyett ﻿x *= 10 \texttt {x *= 10} x *= 10

tenary => let variablename = (condition) ? value1: value2﻿

Objektumok
==========
    Mutable: az adott változó értéke meg tud változni, tud mutálódni.
    Immutable: értelemszerűen az előbbi ellentéte. Tehát az ilyen változót vagy értéket lehet olvasni, de írni - változtatni nem.
    let user={
        key: value,
  name:'Kiss Ramóna',
  age: 20,
  city:'Bp'
}
let admin=new Object();
let costumer={};/*First Hand */

Hivatkozás => user.name

alert(Object.keys(user)+' '+Object.values(user)+' - '+Object.entries(user)+' - '+Object.entries(user)[1])

elemeinek a számát nem tudjuk lekérni, de a kulcsok és az értékeinek is le

for... in ciklus
    kulcsokon meg végig

for...of ciklus
    értékeken meg végig
    Array-like lehet használni
    ﻿let iterable =\texttt {let iterable =}let iterable =﻿ ﻿[10, 20, 30];\texttt{[10, 20, 30];}[10, 20, 30];﻿
﻿for (let value of iterable)\texttt {for (let value of iterable)} for (let value of iterable)﻿ ﻿{ value += 1; console.log(value); } \texttt {\{    value += 1;  console.log(value);    \} }{ value += 1; console.log(value); } 